<div class="upload-formats">Supports: GLTF, GLB, OBJ</div>
        </div>
        <input type="file" id="fileInput" class="file-input" accept=".gltf,.glb,.obj" multiple>
        
        <!-- Model List -->
        <div class="models-list" id="modelsList">
            <div style="text-align: center; color: rgba(255,255,255,0.5); padding: 20px; font-size: 12px;">
                No 3D models uploaded yet
            </div>
        </div>
        
        <!-- Simple Model Controls -->
        <div id="modelControls" style="display: none; margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
            <div style="font-size: 12px; color: #4ecdc4; margin-bottom: 10px;">
                Selected: <span id="selectedModelName">None</span>
            </div>
            <button id="deleteModelBtn" class="btn btn-danger" style="width: 100%;">üóëÔ∏è Delete Model</button>
        </div>
    </div>
    
    <!-- Three.js Scripts - Using ES6 modules for better compatibility -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.149.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.149.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        // Import Three.js modules
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        
        // Make THREE available globally for debugging
        window.THREE = THREE;
        
        // Auth check and initialization
        const API_BASE = 'http://localhost:3000/api';
        let authToken = localStorage.getItem('authToken');
        let currentUser = JSON.parse(localStorage.getItem('user') || '{}');
        let currentWorkspaceId = localStorage.getItem('currentWorkspaceId');
        
        // Check authentication
        if (!authToken) {
            window.location.href = 'index.html';
        }
        
        // If no workspace selected, redirect to workspace selector
        if (!currentWorkspaceId) {
            window.location.href = 'workspace-selector.html';
        }
        
        // Initialize user info safely
        const userNameEl = document.getElementById('userName');
        const userEmailEl = document.getElementById('userEmail');
        const userAvatarEl = document.getElementById('userAvatar');
        const currentWorkspaceIdEl = document.getElementById('currentWorkspaceId');
        
        if (userNameEl) userNameEl.textContent = currentUser.username || 'User';
        if (userEmailEl) userEmailEl.textContent = currentUser.email || '';
        if (userAvatarEl) userAvatarEl.textContent = (currentUser.username || 'U')[0].toUpperCase();
        if (currentWorkspaceIdEl) currentWorkspaceIdEl.textContent = currentWorkspaceId || 'Loading...';
        
        // Socket connection
        const socket = io('http://localhost:3000', { 
            transports: ['websocket'],
            auth: {
                token: authToken,
                user: currentUser
            }
        });
        
        // Global variables
        const otherUsers = {};
        const onlineUsers = {};
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // 3D Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        
        // Environment setup
        const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x888888);
        scene.add(gridHelper);
        
        const planeGem = new THREE.PlaneGeometry(50, 50);
        const planeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xaaaaaa, 
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8
        });
        const plane = new THREE.Mesh(planeGem, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);
        
        // User avatar
        const avatarGeo = new THREE.SphereGeometry(0.2, 32, 32);
        const avatarMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
        const avatar = new THREE.Mesh(avatarGeo, avatarMaterial);
        avatar.castShadow = true;
        scene.add(avatar);
        avatar.position.y = 0.2;
        
        // Movement controls
        let moveX = 0, moveZ = 0;
        
        // Enhanced lighting for better 3D model visibility
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const pointLight1 = new THREE.PointLight(0xffffff, 0.5);
        pointLight1.position.set(10, 10, 10);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xffffff, 0.5);
        pointLight2.position.set(-10, 10, -10);
        scene.add(pointLight2);
        
        camera.position.set(3, 3, 5);
        camera.lookAt(0, 0, 0);
        
        // 3D Models and Sticky Notes storage
        const stickyNotes = {};
        const threeDModels = {};
        let selectedModel = null;
        
        // Setup loaders with proper configuration
        const gltfLoader = new GLTFLoader();
        const objLoader = new OBJLoader();
        
        // Configure DRACO decoder for compressed GLTF models
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://unpkg.com/three@0.149.0/examples/js/libs/draco/');
        gltfLoader.setDRACOLoader(dracoLoader);
        
        console.log('‚úÖ Three.js loaders initialized successfully');
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('‚úÖ Connected to server');
            const loadingEl = document.getElementById('loading');
            if (loadingEl) loadingEl.style.display = 'none';
            
            console.log('üè† Joining workspace:', currentWorkspaceId);
            socket.emit('joinWorkspace', {
                workspaceId: currentWorkspaceId,
                userId: currentUser._id,
                userInfo: currentUser
            });
        });
        
        socket.on('disconnect', () => {
            console.log('‚ùå Disconnected from server');
            const loadingEl = document.getElementById('loading');
            if (loadingEl) {
                loadingEl.style.display = 'flex';
                loadingEl.innerHTML = '<div class="loading-spinner"></div>Reconnecting...';
            }
        });
        
        // Model-related socket events
        socket.on('modelUploaded', ({ model }) => {
            console.log('üì¶ New model uploaded:', model);
            loadThreeDModel(model);
        });
        
        socket.on('modelMoved', ({ modelId, position, rotation, scale }) => {
            console.log('üì¶ Model moved:', { modelId, position, rotation, scale });
            const model = threeDModels[modelId];
            if (model) {
                if (position) model.position.set(position.x, position.y, position.z);
                if (rotation) model.rotation.set(rotation.x, rotation.y, rotation.z);
                if (scale) model.scale.set(scale.x, scale.y, scale.z);
            }
        });
        
        socket.on('modelDeleted', ({ modelId }) => {
            console.log('üóëÔ∏è Model deleted:', modelId);
            const model = threeDModels[modelId];
            if (model) {
                scene.remove(model);
                delete threeDModels[modelId];
                updateModelsListDisplay();
                if (selectedModel && selectedModel.userData.id === modelId) {
                    selectedModel = null;
                    document.getElementById('modelControls').style.display = 'none';
                }
            }
        });
        
        // Existing socket handlers for users and notes...
        socket.on('existingUsers', (users) => {
            console.log('üë• Received existing users:', users);
            Object.entries(users).forEach(([id, userData]) => {
                if (id !== socket.id) {
                    createOtherUser(id, userData);
                    addToOnlineUsers(id, userData);
                }
            });
        });
        
        socket.on('userJoined', (data) => {
            console.log('üëã User joined:', data);
            if (data.socketId === socket.id) {
                return;
            }
            createOtherUser(data.socketId, data);
            addToOnlineUsers(data.socketId, data);
        });
        
        socket.on('userMoved', ({ socketId, position }) => {
            const user = otherUsers[socketId];
            if (user) {
                user.position.set(position.x, position.y, position.z);
            }
        });
        
        socket.on('userLeft', ({ socketId }) => {
            console.log('üëã User left:', socketId);
            if (otherUsers[socketId]) {
                scene.remove(otherUsers[socketId]);
                delete otherUsers[socketId];
                removeFromOnlineUsers(socketId);
            }
        });
        
        socket.on('noteCreated', ({ note }) => {
            console.log('üìù Note created:', note);
            const pos = new THREE.Vector3(note.position.x, note.position.y, note.position.z);
            createStickyNote(pos, note.text, note.id);
        });
        
        socket.on('noteUpdated', ({ note }) => {
            console.log('‚úèÔ∏è Note updated:', note);
            const stickyNote = stickyNotes[note.id];
            if (stickyNote) {
                if (note.text) stickyNote.setText(note.text);
                if (note.position) {
                    const pos = new THREE.Vector3(note.position.x, note.position.y, note.position.z);
                    stickyNote.setPosition(pos);
                }
            }
        });
        
        socket.on('noteDeleted', ({ noteId }) => {
            console.log('üóëÔ∏è Note deleted:', noteId);
            const stickyNote = stickyNotes[noteId];
            if (stickyNote) {
                stickyNote.destroy();
            }
        });
        
        // 3D Model Upload Functionality
        function setupFileUpload() {
            const fileUploadArea = document.getElementById('fileUploadArea');
            const fileInput = document.getElementById('fileInput');
            
            // Click to upload
            fileUploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            // File input change
            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });
            
            // Drag and drop
            fileUploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                fileUploadArea.classList.add('dragover');
            });
            
            fileUploadArea.addEventListener('dragleave', () => {
                fileUploadArea.classList.remove('dragover');
            });
            
            fileUploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                fileUploadArea.classList.remove('dragover');
                handleFiles(e.dataTransfer.files);
            });
        }
        
        function handleFiles(files) {
            Array.from(files).forEach(file => {
                if (isValidModelFile(file)) {
                    // For now, load files directly in browser instead of uploading to server
                    loadModelFileDirectly(file);
                } else {
                    alert(`Unsupported file type: ${file.name}. Please use GLTF, GLB, or OBJ files.`);
                }
            });
        }
        
        function isValidModelFile(file) {
            const validExtensions = ['.gltf', '.glb', '.obj'];
            const fileName = file.name.toLowerCase();
            return validExtensions.some(ext => fileName.endsWith(ext));
        }
        
        function loadModelFileDirectly(file) {
            console.log('üì§ Loading model directly:', file.name);
            
            const modelId = `model_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const fileType = file.name.toLowerCase().split('.').pop();
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    if (fileType === 'gltf') {
                        const gltfData = JSON.parse(e.target.result);
                        loadGLTFFromData(gltfData, file.name, modelId);
                    } else if (fileType === 'glb') {
                        loadGLBFromBuffer(e.target.result, file.name, modelId);
                    } else if (fileType === 'obj') {
                        loadOBJFromText(e.target.result, file.name, modelId);
                    }
                } catch (error) {
                    console.error('Error loading model:', error);
                    alert('Error loading model: ' + error.message);
                }
            };
            
            if (fileType === 'glb') {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsText(file);
            }
        }
        
        function loadGLTFFromData(gltfData, fileName, modelId) {
            console.log('üîÑ Loading GLTF data...');
            
            gltfLoader.parse(JSON.stringify(gltfData), '', function(gltf) {
                const model = gltf.scene;
                setupModel(model, { name: fileName, fileType: 'gltf' }, modelId);
                console.log('‚úÖ GLTF model loaded successfully');
            }, function(error) {
                console.error('‚ùå GLTF loading failed:', error);
                alert('Failed to load GLTF model: ' + error.message);
            });
        }
        
        function loadGLBFromBuffer(buffer, fileName, modelId) {
            console.log('üîÑ Loading GLB buffer...');
            
            gltfLoader.parse(buffer, '', function(gltf) {
                const model = gltf.scene;
                setupModel(model, { name: fileName, fileType: 'glb' }, modelId);
                console.log('‚úÖ GLB model loaded successfully');
            }, function(error) {
                console.error('‚ùå GLB loading failed:', error);
                alert('Failed to load GLB model: ' + error.message);
            });
        }
        
        function loadOBJFromText(objText, fileName, modelId) {
            console.log('üîÑ Loading OBJ text...');
            
            try {
                const object = objLoader.parse(objText);
                
                // Add basic material to OBJ models
                object.traverse(function(child) {
                    if (child.isMesh) {
                        child.material = new THREE.MeshStandardMaterial({ 
                            color: 0x888888,
                            metalness: 0.2,
                            roughness: 0.8
                        });
                    }
                });
                
                setupModel(object, { name: fileName, fileType: 'obj' }, modelId);
                console.log('‚úÖ OBJ model loaded successfully');
            } catch (error) {
                console.error('‚ùå OBJ loading failed:', error);
                alert('Failed to load OBJ model: ' + error.message);
            }
        }
        
        function setupModel(model, modelData, modelId) {
            // Set default position
            model.position.set(0, 1, 0);
            model.rotation.set(0, 0, 0);
            model.scale.set(1, 1, 1);
            
            // Add metadata
            model.userData = {
                id: modelId,
                name: modelData.name,
                type: '3dmodel',
                originalData: modelData
            };
            
            // Enable shadows
            model.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            // Add to scene and tracking
            scene.add(model);
            threeDModels[modelId] = model;
            
            console.log('‚úÖ Model added to scene:', modelData.name);
            updateModelsListDisplay();
            
            // Notify other users (simplified for local testing)
            socket.emit('modelUploaded', {
                workspaceId: currentWorkspaceId,
                model: {
                    id: modelId,
                    name: modelData.name,
                    fileType: modelData.fileType,
                    position: { x: 0, y: 1, z: 0 },
                    rotation: { x: 0, y: 0, z: 0 },
                    scale: { x: 1, y: 1, z: 1 }
                }
            });
        }
        
        function updateModelsListDisplay() {
            const modelsList = document.getElementById('modelsList');
            const models = Object.values(threeDModels);
            
            if (models.length === 0) {
                modelsList.innerHTML = `
                    <div style="text-align: center; color: rgba(255,255,255,0.5); padding: 20px; font-size: 12px;">
                        No 3D models uploaded yet
                    </div>
                `;
                return;
            }
            
            modelsList.innerHTML = models.map(model => `
                <div class="model-item ${selectedModel === model ? 'selected' : ''}" 
                     onclick="selectModel('${model.userData.id}')">
                    <div class="model-info">
                        <h4>${model.userData.name}</h4>
                        <p>Type: ${model.userData.originalData.fileType?.toUpperCase() || 'Model'}</p>
                    </div>
                    <div class="model-actions">
                        <button class="btn btn-secondary" style="padding: 4px 8px; font-size: 10px;" 
                                onclick="event.stopPropagation(); focusOnModel('${model.userData.id}')">üëÅÔ∏è</button>
                        <button class="btn btn-danger" style="padding: 4px 8px; font-size: 10px;" 
                                onclick="event.stopPropagation(); deleteModel('${model.userData.id}')">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }
        
        function selectModel(modelId) {
            const model = threeDModels[modelId];
            if (!model) return;
            
            selectedModel = model;
            updateModelsListDisplay();
            
            // Show controls
            const controls = document.getElementById('modelControls');
            controls.style.display = 'block';
            
            // Update control values
            document.getElementById('selectedModelName').textContent = model.userData.name;
        }
        
        function focusOnModel(modelId) {
            const model = threeDModels[modelId];
            if (!model) return;
            
            // Animate camera to focus on model
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 2;
            
            // Move camera to look at the model
            camera.position.set(
                center.x + distance,
                center.y + distance * 0.5,
                center.z + distance
            );
            camera.lookAt(center);
        }
        
        function deleteModel(modelId) {
            if (confirm('Are you sure you want to delete this 3D model?')) {
                const model = threeDModels[modelId];
                if (model) {
                    scene.remove(model);
                    delete threeDModels[modelId];
                    
                    if (selectedModel === model) {
                        selectedModel = null;
                        document.getElementById('modelControls').style.display = 'none';
                    }
                    
                    updateModelsListDisplay();
                    
                    // Notify other users
                    socket.emit('modelDeleted', {
                        workspaceId: currentWorkspaceId,
                        modelId: modelId
                    });
                }
            }
        }
        
        // Setup delete button
        document.getElementById('deleteModelBtn').addEventListener('click', () => {
            if (selectedModel) {
                deleteModel(selectedModel.userData.id);
            }
        });
        
        // Enhanced mouse interaction for both notes and 3D models
        let draggingNote = null;
        let isDragging = false;
        let draggingModel = null;
        let isDraggingModel = false;
        let dragStartTime = 0;
        let dragStartPosition = { x: 0, y: 0 };
        
        window.addEventListener('mousedown', (e) => {
            // Check if clicked on UI elements
            if (e.target.closest('.ui-panel') || e.target.closest('button') || e.target.closest('input')) {
                return;
            }
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            // Check for 3D models first
            const modelMeshes = Object.values(threeDModels);
            const modelIntersects = raycaster.intersectObjects(modelMeshes, true);
            
            if (modelIntersects.length > 0) {
                // Find the top-level model object
                let targetModel = modelIntersects[0].object;
                while (targetModel.parent && !targetModel.userData.type) {
                    targetModel = targetModel.parent;
                }
                
                if (targetModel.userData.type === '3dmodel') {
                    draggingModel = targetModel;
                    dragStartTime = Date.now();
                    dragStartPosition = { x: e.clientX, y: e.clientY };
                    selectModel(targetModel.userData.id);
                    e.preventDefault();
                    return;
                }
            }
            
            // Check for sticky notes
            const noteMeshes = Object.values(stickyNotes).map(note => note.mesh);
            const noteIntersects = raycaster.intersectObjects(noteMeshes);
            
            if (noteIntersects.length > 0) {
                draggingNote = noteIntersects[0].object;
                dragStartTime = Date.now();
                dragStartPosition = { x: e.clientX, y: e.clientY };
                e.preventDefault();
            }
        });
        
        window.addEventListener('mousemove', (e) => {
            if (draggingModel) {
                const dragDistance = Math.sqrt(
                    Math.pow(e.clientX - dragStartPosition.x, 2) + 
                    Math.pow(e.clientY - dragStartPosition.y, 2)
                );
                
                if (dragDistance > 5 && !isDraggingModel) {
                    isDraggingModel = true;
                }
                
                if (isDraggingModel) {
                    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    
                    const intersects = raycaster.intersectObject(plane);
                    if (intersects.length > 0) {
                        const point = intersects[0].point;
                        draggingModel.position.set(point.x, point.y + 1, point.z);
                    }
                }
                return;
            }
            
            if (draggingNote) {
                const dragDistance = Math.sqrt(
                    Math.pow(e.clientX - dragStartPosition.x, 2) + 
                    Math.pow(e.clientY - dragStartPosition.y, 2)
                );
                
                if (dragDistance > 5 && !isDragging) {
                    isDragging = true;
                }
                
                if (isDragging) {
                    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    
                    const intersects = raycaster.intersectObject(plane);
                    if (intersects.length > 0) {
                        const point = intersects[0].point;
                        const stickyNote = draggingNote.userData.stickyNote;
                        stickyNote.setPosition(point);
                        
                        socket.emit('updateNote', {
                            noteId: stickyNote.id,
                            updates: {
                                position: { x: point.x, y: point.y, z: point.z }
                            }
                        });
                    }
                }
            }
        });
        
        window.addEventListener('mouseup', (e) => {
            if (draggingModel) {
                if (isDraggingModel) {
                    // Send final position to server
                    socket.emit('modelMoved', {
                        workspaceId: currentWorkspaceId,
                        modelId: draggingModel.userData.id,
                        position: { 
                            x: draggingModel.position.x, 
                            y: draggingModel.position.y, 
                            z: draggingModel.position.z 
                        }
                    });
                }
                isDraggingModel = false;
                draggingModel = null;
            }
            
            if (draggingNote) {
                isDragging = false;
                draggingNote = null;
            }
        });
        
        window.addEventListener('click', (e) => {
            if (isDragging || isDraggingModel || draggingNote || draggingModel) {
                return;
            }
            
            // Check if clicked on UI elements
            if (e.target.closest('.ui-panel') || e.target.closest('button') || e.target.closest('input')) {
                return;
            }
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            // Check if clicking on existing objects
            const allMeshes = [
                ...Object.values(stickyNotes).map(note => note.mesh),
                ...Object.values(threeDModels)
            ];
            const intersects = raycaster.intersectObjects(allMeshes, true);
            
            if (intersects.length === 0) {
                // Create sticky note on empty space
                const planeIntersects = raycaster.intersectObject(plane);
                if (planeIntersects.length > 0) {
                    const point = planeIntersects[0].point;
                    
                    socket.emit('createNote', {
                        text: "New Note",
                        position: { x: point.x, y: point.y, z: point.z },
                        workspaceId: currentWorkspaceId
                    });
                }
            }
        });
        
        window.addEventListener('dblclick', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const meshes = Object.values(stickyNotes).map(note => note.mesh);
            const intersects = raycaster.intersectObjects(meshes);
            
            if (intersects.length > 0) {
                const stickyNote = intersects[0].object.userData.stickyNote;
                if (stickyNote) {
                    const newText = prompt('Edit note:', stickyNote.getText());
                    if (newText && newText.trim()) {
                        stickyNote.setText(newText.trim());
                        
                        socket.emit('updateNote', {
                            noteId: stickyNote.id,
                            updates: { text: newText.trim() }
                        });
                    }
                }
            }
        });
        
        // Helper functions
        function createOtherUser(id, userData) {
            if (otherUsers[id]) {
                return;
            }
            
            const geometry = new THREE.SphereGeometry(0.2, 32, 32);
            const color = userData.avatar?.color || '#ff0000';
            const material = new THREE.MeshStandardMaterial({ 
                color: color
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(
                userData.position?.x || 0,
                userData.position?.y || 0.2,
                userData.position?.z || 0
            );
            mesh.castShadow = true;
            scene.add(mesh);
            
            // Add username label
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(userData.userInfo?.username || 'User', 128, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(2, 0.5, 1);
            sprite.position.set(0, 0.8, 0);
            
            mesh.add(sprite);
            otherUsers[id] = mesh;
        }
        
        function addToOnlineUsers(socketId, userData) {
            onlineUsers[socketId] = userData;
            updateOnlineUsersList();
        }
        
        function removeFromOnlineUsers(socketId) {
            delete onlineUsers[socketId];
            updateOnlineUsersList();
        }
        
        function updateOnlineUsersList() {
            const usersList = document.getElementById('usersList');
            if (!usersList) return;
            
            if (Object.keys(onlineUsers).length === 0) {
                usersList.innerHTML = '<div style="color: #666; font-size: 12px;">No other users online</div>';
                return;
            }
            
            usersList.innerHTML = '';
            
            Object.entries(onlineUsers).forEach(([id, user]) => {
                const userDiv = document.createElement('div');
                userDiv.className = 'online-user';
                
                const avatarDiv = document.createElement('div');
                avatarDiv.className = 'user-avatar';
                avatarDiv.style.backgroundColor = user.avatar?.color || '#4ecdc4';
                avatarDiv.textContent = (user.userInfo?.username || 'U')[0].toUpperCase();
                
                const nameDiv = document.createElement('div');
                nameDiv.textContent = user.userInfo?.username || 'Anonymous';
                nameDiv.style.fontSize = '12px';
                
                const statusDiv = document.createElement('div');
                statusDiv.style.width = '8px';
                statusDiv.style.height = '8px';
                statusDiv.style.borderRadius = '50%';
                statusDiv.style.backgroundColor = '#27ae60';
                statusDiv.style.marginLeft = 'auto';
                
                userDiv.appendChild(avatarDiv);
                userDiv.appendChild(nameDiv);
                userDiv.appendChild(statusDiv);
                usersList.appendChild(userDiv);
            });
        }
        
        // StickyNote class (keeping existing functionality)
        class StickyNote {
            constructor(position, text = "New Note", id = null) {
                this.id = id || crypto.randomUUID();
                this.text = text;
                this.position = position.clone();
                this.mesh = null;
                this.canvas = null;
                this.texture = null;
                
                this.createMesh();
                this.updateVisual();
                
                scene.add(this.mesh);
                stickyNotes[this.id] = this;
            }
            
            createMesh() {
                this.canvas = document.createElement('canvas');
                this.canvas.width = 512;
                this.canvas.height = 320;
                
                this.texture = new THREE.CanvasTexture(this.canvas);
                this.texture.needsUpdate = true;
                
                const material = new THREE.MeshBasicMaterial({ 
                    map: this.texture, 
                    side: THREE.DoubleSide,
                    transparent: true
                });
                const geometry = new THREE.PlaneGeometry(2, 1.2);
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                this.mesh.position.y += 0.6;
                
                this.mesh.userData.stickyNote = this;
                this.mesh.userData.id = this.id;
                this.mesh.userData.type = 'stickyNote';
            }
            
            updateVisual() {
                const ctx = this.canvas.getContext('2d');
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Note background
                ctx.fillStyle = '#ffff88';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Border
                ctx.strokeStyle = '#e6d55a';
                ctx.lineWidth = 8;
                ctx.strokeRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Text
                ctx.fillStyle = '#000';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                
                // Simple text wrapping
                const words = this.text.split(' ');
                const maxWidth = this.canvas.width - 40;
                let line = '';
                let y = 40;
                
                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = ctx.measureText(testLine);
                    
                    if (metrics.width > maxWidth && n > 0) {
                        ctx.fillText(line, 20, y);
                        line = words[n] + ' ';
                        y += 45;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, 20, y);
                
                this.texture.needsUpdate = true;
            }
            
            setText(newText) {
                this.text = newText;
                this.updateVisual();
            }
            
            setPosition(newPosition) {
                this.position.copy(newPosition);
                this.mesh.position.copy(newPosition);
                this.mesh.position.y += 0.6;
            }
            
            getText() {
                return this.text;
            }
            
            destroy() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                    if (this.texture) {
                        this.texture.dispose();
                    }
                }
                delete stickyNotes[this.id];
            }
        }
        
        function createStickyNote(position, text = "New Note", id = null) {
            return new StickyNote(position, text, id);
        }
        
        // Input handlers
        document.addEventListener('keydown', (e) => {
            if (e.key == 'ArrowUp') moveZ = -0.05;
            if (e.key == 'ArrowDown') moveZ = 0.05;
            if (e.key == "ArrowLeft") moveX = -0.05;
            if (e.key == 'ArrowRight') moveX = 0.05;
        });
        
        document.addEventListener('keyup', (e) => {
            if (['ArrowUp', 'ArrowDown'].includes(e.key)) moveZ = 0;
            if (['ArrowLeft', 'ArrowRight'].includes(e.key)) moveX = 0;
        });
        
        // Button handlers
        document.getElementById('logoutBtn')?.addEventListener('click', () => {
            localStorage.removeItem('authToken');
            localStorage.removeItem('user');
            localStorage.removeItem('isDemo');
            localStorage.removeItem('currentWorkspaceId');
            window.location.href = 'index.html';
        });
        
        document.getElementById('backBtn')?.addEventListener('click', () => {
            window.location.href = 'workspace-selector.html';
        });
        
        document.getElementById('shareBtn')?.addEventListener('click', () => {
            const shareText = `Join my 3D Workspace!\nWorkspace ID: ${currentWorkspaceId}\nOpen: ${window.location.origin}`;
            
            if (navigator.share) {
                navigator.share({
                    title: '3D Collaborative Workspace',
                    text: shareText,
                    url: window.location.origin
                });
            } else {
                navigator.clipboard.writeText(shareText).then(() => {
                    alert('Workspace sharing info copied to clipboard!');
                }).catch(() => {
                    prompt('Share this workspace:', shareText);
                });
            }
        });
        
        document.getElementById('copyIdBtn')?.addEventListener('click', () => {
            navigator.clipboard.writeText(currentWorkspaceId).then(() => {
                const btn = document.getElementById('copyIdBtn');
                if (btn) {
                    const originalText = btn.innerHTML;
                    btn.innerHTML = '‚úÖ Copied!';
                    setTimeout(() => {
                        btn.innerHTML = originalText;
                    }, 2000);
                }
            });
        });
        
        document.getElementById('saveBtn')?.addEventListener('click', () => {
            const notes = Object.values(stickyNotes).map(note => ({
                id: note.id,
                text: note.getText(),
                position: {
                    x: note.position.x,
                    y: note.position.y,
                    z: note.position.z
                }
            }));
            
            const models = Object.values(threeDModels).map(model => ({
                id: model.userData.id,
                name: model.userData.name,
                position: {
                    x: model.position.x,
                    y: model.position.y,
                    z: model.position.z
                },
                rotation: {
                    x: model.rotation.x,
                    y: model.rotation.y,
                    z: model.rotation.z
                },
                scale: {
                    x: model.scale.x,
                    y: model.scale.y,
                    z: model.scale.z
                }
            }));
            
            socket.emit('saveWorkspace', {
                workspaceId: currentWorkspaceId,
                notes: notes,
                models: models
            });
            
            const btn = document.getElementById('saveBtn');
            if (btn) {
                const originalText = btn.innerHTML;
                btn.innerHTML = '‚úÖ Saved!';
                setTimeout(() => {
                    btn.innerHTML = originalText;
                }, 2000);
            }
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            avatar.position.x += moveX;
            avatar.position.z += moveZ;
            camera.position.x = avatar.position.x + 3;
            camera.position.z = avatar.position.z + 5;
            camera.lookAt(avatar.position);
            
            // Make notes face camera
            Object.values(stickyNotes).forEach(note => {
                note.mesh.lookAt(camera.position);
            });
            
            // Send position updates
            socket.emit('updatePosition', {
                x: avatar.position.x,
                y: avatar.position.y,
                z: avatar.position.z
            });
            
            renderer.render(scene, camera);
        }
        
        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize everything
        function init() {
            setupFileUpload();
            animate();
            
            // Add a test cube to verify 3D rendering works
            const testGeometry = new THREE.BoxGeometry(1, 1, 1);
            const testMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            const testCube = new THREE.Mesh(testGeometry, testMaterial);
            testCube.position.set(2, 0.5, 2);
            testCube.castShadow = true;
            scene.add(testCube);
            
            console.log('‚úÖ 3D Workspace initialized with test cube');
        }
        
        // Start when page loads
        window.addEventListener('load', init);
        
        // Make functions globally available for debugging
        window.selectModel = selectModel;
        window.focusOnModel = focusOnModel;
        window.deleteModel = deleteModel;
        window.loadThreeDModel = loadThreeDModel;
        
        function loadThreeDModel(modelData) {
            console.log('üéØ Loading 3D model from data:', modelData);
            
            // This would typically load from server, but for now we'll create a placeholder
            const modelId = modelData.id || crypto.randomUUID();
            const position = modelData.position || { x: 0, y: 1, z: 0 };
            
            // Create a simple placeholder for remote models
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xff6b6b,
                metalness: 0.3,
                roughness: 0.7
            });
            const placeholder = new THREE.Mesh(geometry, material);
            
            setupModel(placeholder, modelData, modelId, position, modelData.rotation, modelData.scale);
        }
        
        console.log('üéâ 3D Workspace module loaded successfully!');
    </script>
</body>
</html>
                <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Collaborative Workspace</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        
        .ui-panel {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
        }
        
        .top-left {
            top: 20px;
            left: 20px;
            max-width: 300px;
        }
        
        .top-right {
            top: 20px;
            right: 20px;
        }
        
        .bottom-left {
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
        }
        
        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            margin: 5px;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: #4ecdc4;
            color: white;
        }
        
        .btn-primary:hover {
            background: #44a08d;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .btn-danger {
            background: #e74c3c;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        /* File Upload Styles */
        .file-upload-area {
            border: 2px dashed #4ecdc4;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin: 10px 0;
            background: rgba(78, 205, 196, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .file-upload-area:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: #44a08d;
        }
        
        .file-upload-area.dragover {
            background: rgba(78, 205, 196, 0.3);
            border-color: #2ecc71;
        }
        
        .file-input {
            display: none;
        }
        
        .upload-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        .upload-text {
            font-size: 14px;
            color: #4ecdc4;
        }
        
        .upload-formats {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 5px;
        }
        
        /* Model List */
        .models-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .model-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            margin-bottom: 5px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .model-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .model-item.selected {
            background: rgba(78, 205, 196, 0.3);
            border: 1px solid #4ecdc4;
        }
        
        .model-info h4 {
            margin: 0;
            font-size: 14px;
            color: white;
        }
        
        .model-info p {
            margin: 2px 0 0 0;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .model-actions {
            display: flex;
            gap: 5px;
        }
        
        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            color: white;
            font-size: 18px;
        }
        
        .loading-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #4ecdc4;
            animation: spin 1s ease-in-out infinite;
            margin-right: 15px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .workspace-id {
            font-family: monospace;
            font-size: 11px;
            word-break: break-all;
            color: #4ecdc4;
            margin-top: 5px;
        }

        /* User info styles */
        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        .online-users {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .online-user {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .user-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading-overlay">
        <div class="loading-spinner"></div>
        Connecting to workspace...
    </div>

    <div class="ui-panel top-left">
        <h3>üåê 3D Workspace</h3>
        <div>üñ±Ô∏è Click: Create sticky note</div>
        <div>‚å®Ô∏è Arrow keys: Move avatar</div>
        <div>üì¶ Drag models to move them</div>
        
        <div>
            <button id="saveBtn" class="btn btn-primary">üíæ Save</button>
            <button id="shareBtn" class="btn btn-secondary">üîó Share</button>
            <button id="backBtn" class="btn btn-secondary">‚¨ÖÔ∏è Back</button>
        </div>
        
        <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
            <div style="font-size: 11px; color: rgba(255,255,255,0.7);">Workspace ID:</div>
            <div class="workspace-id" id="currentWorkspaceId">Loading...</div>
            <button id="copyIdBtn" class="btn btn-secondary" style="font-size: 10px; padding: 4px 8px; margin-top: 5px;">üìã Copy</button>
        </div>
        
        <div class="online-users">
            <h4 style="margin: 0 0 10px 0; color: #4ecdc4;">Online Users</h4>
            <div id="usersList">Loading...</div>
        </div>
    </div>

    <div class="ui-panel top-right">
        <div class="user-info">
            <div class="avatar" id="userAvatar">U</div>
            <div>
                <div id="userName">Loading...</div>
                <div style="font-size: 12px; opacity: 0.7;" id="userEmail"></div>
            </div>
        </div>
        <div>
            <button id="logoutBtn" class="btn btn-primary">üö™ Logout</button>
        </div>
    </div>

    <!-- 3D Model Controls Panel -->
    <div class="ui-panel bottom-left">
        <h4 style="margin: 0 0 10px 0; color: #4ecdc4;">üì¶ 3D Models</h4>
        
        <!-- File Upload Area -->
        <div class="file-upload-area" id="fileUploadArea">
            <div class="upload-icon">üìÅ</div>
            <div class="upload-text">Click or drag 3D models here</div>
            <div class="upload-formats">Supports: GLTF, GLB, O